{"name":"Async-ls","tagline":"Higher order functions, compositions and common operations for asynchronous programming in LiveScript.","body":"# async-ls\r\n\r\nThis library provides powerful higher-order functions and other utilities\r\nfor working with asynchronous functions with callbacks or ES6 promises.\r\n\r\nCallback utility functions are in \r\n\r\n\t{callbacks} = require \\async-ls\r\n\t\r\nand promise based functions are in \r\n\r\n\t{promises} = require \\async-ls\r\n\t\r\nThere's also a monad library accessible by:\r\n\r\n    {monads} = require \\async-ls\r\n\t\r\nCallback and promise functions are similar in their input arguments and their result. Callback functions return a callback function with the signature of `(error, result) -> void` and promise functions return a `Promise` object.\r\n\r\nTo get the individual functions use LiveScript pattern matching syntax:\r\n\r\n    {\r\n    \tpromises: {\r\n    \t\tLazyPromise, parallel-map, parallel-limited-filter\r\n    \t},\r\n    \tmonads: {\r\n    \t    filterM, liftM\r\n    \t}\r\n    } = require \\async-ls\r\n\r\nTo build:\r\n\r\n    make build\r\n    \r\nBuild for browsers (using Browserify):\r\n\r\n    make async-browser.js\r\n    \r\nBuild for browsers (callbacks library only):\r\n\r\n    make callbacks-browser.js \r\n    \r\nBuild for browsers (promises library only):\r\n\r\n    make promises-browser.js\r\n\r\nTo test:\r\n\r\n    ./test.sh\r\n\r\n\r\n# Monads\r\n\r\n    {monads} = require \\async-ls\r\n\r\n### monadize\r\nMonads work best in statically typed languages. To make monadic functions\r\nwork in LiveScript, we need to pass the type of the monad to many of the monadic operations.\r\n`monadize` encapsulates the monad's type: `return` aka `pure`, `fmap` and `bind` functions.\r\n\r\n    monadize :: \r\n        (a -> m a) ->                   # pure\r\n        ((a -> b) -> m a -> m b) ->     # fmap\r\n        (m a -> (a -> m b) -> m b) ->   # bind\r\n        Monad\r\n\r\n\r\n\r\n### kcompM\r\nLeft-to-right Kleisli composition of monads.\r\n\r\n\tkcompM :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c)\r\n\r\n\r\n\r\n### joinM\r\nRemove one level of monadic structure, projecting its bound argument into the outer level.\r\n\t\r\n\t(Monad m) => m m x -> m x\r\n\r\n\r\n\r\n### filterM\r\nFilter the list by applying the predicate function to \r\neach of its element one-by-one in serial order.\r\n\t\r\n\tfilterM :: (Monad x) => (x -> m Boolean) -> [x] -> m [x]\r\n\r\n\r\n\r\n### foldM\r\nThe `foldM` function is analogous to `foldl`, except that its result is\r\nencapsulated in a monad.\r\n\t\r\n\tfoldM :: (Monad a) => (a -> b -> m a) -> a -> [b] -> m a\r\n\r\n\r\n\r\n### sequenceM\r\nEvaluate each action in the sequence from left to right,\r\nand collect the results.\r\n\t\r\n\tsequenceM :: (Monad x) => [m x] -> m [x]\r\n\r\n\r\n\r\n### mapM\r\nIt is equivalent to `sequenceM . (map f)`.\r\n\t\r\n\t(Monad m) => (x -> m x) -> [x] -> m [x]\r\n\r\n\r\n\r\n### liftM\r\nPromote a function to a monad.\r\n\t\r\n\tliftM  :: (Monad m) => (a -> r) -> m a -> m r\r\n\r\n\r\n\r\n### liftM2\r\nPromote a function to a monad, scanning the monadic arguments from\r\nleft to right.\r\n\t\r\n\tliftM2 :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r\r\n\r\n\r\n\r\n### ap\r\n``monad.pureM f `ap` x1 `ap` ... `ap` `` is equivalent to `(liftMn monad) f x1 x2 ... xn`\r\n\t\r\n\tap :: (Monad m) => m (a -> b) -> m a -> m b\r\n\r\n\r\n\r\n### Some Monad Instances:\r\n\r\n    list-monad :: Monad     # []\r\n\t\r\n\teither-monad :: Monad   # [error, right]\r\n\t\r\n\twriter-monad :: Monad   # [value, monoid]\r\n\t\r\n\r\n\r\n\r\n# Promises\r\n\r\n    {promises} = require \\async-ls\r\n\r\n\r\n## Lazy Promise\r\n`LazyPromise` only starts getting evaluated after `then` is called.\r\n\r\n    LazyPromise : Promise\r\n\r\n\r\n## Compositions\r\n\r\n    promise-monad :: Monad\r\n\r\n### returnP\r\nInject a value into a promise.\r\n\r\n\treturnP :: x -> Promise x\r\n\r\n\r\n\r\n### fmapP\r\nMap a normal function over a promise.\r\n\r\n\tfmapP :: (x -> y) -> Promise x -> Promise y\r\n\r\n\r\n\r\n### ffmapP\r\n`fmapP` with its arguments flipped.\r\n\r\n\tffmapP :: Promise x -> (x -> y) -> Promise y\r\n\r\n\r\n\r\n### bindP\r\nSequentially compose two promises, passing the value produced\r\nby the first as an argument to the second.\r\n\r\n\tbindP :: Promise x -> (x -> Promise y) -> Promise y\r\n\r\n\r\n\r\n### fbindP\r\n`bindP` with its arguments flipped.\r\n\r\n\tfbindP :: (x -> Promise y) -> Promise x -> Promise y\r\n\r\n\r\n\r\n### filterP\r\nFilter the list by applying the promise predicate function to \r\neach of its element one-by-one in serial order.\r\n\r\n\tfilterP :: (x -> Promise Boolean) -> [x] -> Promise [x]\r\n\r\n\r\n\r\n### foldP\r\nThe `foldP` function is analogous to `foldl`, except that its result is\r\nencapsulated in a promise.\r\n\r\n\tfoldP :: (a -> b -> Promise a) -> a -> [b] -> Promise a\r\n\r\n\r\n\r\n### sequenceP\r\nRun its input (an array of `Promise` s) in parallel\r\n(without waiting for the previous promise to fulfill),\r\nand return the results encapsulated in a promise.\r\n\r\nThe returned promise immidiately gets rejected,\r\nif any of the promises in the input list fail.\r\n\r\n\tsequenceP :: [Promise x] -> Promise [x]\r\n\r\n\r\n\r\n## Lists\r\n\r\n\r\n### parallel-map\r\n\r\n\tparallel-map :: (a -> Promise b) -> [a] -> Promise [b]\r\n\r\n\r\n\r\n### serial-map\r\n\r\n\tserial-map :: (a -> Promise b) -> [a] -> Promise [b]\r\n\r\n\r\n\r\n### parallel-limited-map\r\n\r\n\tparallel-limited-map :: Int -> (x -> Promise y) -> [x] -> Promise [y]\r\n\r\n\r\n\r\n### parallel-filter\r\n\r\n\tparallel-filter :: (x -> m Boolean) -> [x] -> m [x]\r\n\r\n\r\n\r\n### serial-filter\r\nSynonym for `filterP`\r\n\r\n\tserial-filter :: (x -> Promise Boolean) -> [x] -> Promise [x]\r\n\r\n\r\n\r\n### parallel-limited-filter\r\n\r\n\tparallel-limited-filter :: Int -> (x -> Promise Boolean) -> [x] -> Promise x\r\n\r\n\r\n\r\n### parallel-any\r\nRun the boolean predicate (that is encapsulated in a promise) on the list in parallel.\r\nThe returned promise fulfills as soon as a matching item is found with `true`,\r\notherwise `false` if no match was found.\r\n\r\n\tparallel-any :: (x -> Promise Boolean) -> [x] -> Promise Boolean\r\n\r\n\r\n\r\n### serial-any\r\n\r\n\tserial-any :: (x -> m Boolean) -> [x] -> m Boolean\r\n\r\n\r\n\r\n### parallel-limited-any\r\n\r\n\tparallel-limited-any :: Int -> (x -> Promise Boolean) -> [x] -> Promise Boolean\r\n\r\n\r\n\r\n### parallel-all\r\n\r\n\tparallel-all :: (x -> Promise Boolean) -> [x] -> Promise Boolean\r\n\r\n\r\n\r\n### serial-all\r\n\r\n\tserial-all :: (x -> Promise Boolean) -> [x] -> Promise Boolean\r\n\r\n\r\n\r\n### parallel-limited-all\r\n\r\n\tparallel-limited-all :: Int -> (x -> Promise Boolean) -> [x] -> Promise Boolean\r\n\r\n\r\n\r\n### parallel-find\r\nRun the boolean predicate (that is encapsulated in a promise) on the list in parallel.\r\nThe returned promisefulfills as soon as a matching item is found with the\r\nmatching value, otherwise with `null` if no match was found. \r\n\r\n\tparallel-find :: (x -> Promise Boolean) -> [x] -> m \r\n\r\n\r\n\r\n### serial-find\r\n\r\n\tserial-find :: (x -> Promise Boolean) -> [x] -> m x\r\n\r\n\r\n\r\n### parallel-limited-find\r\n\r\n\tparallel-limited-find :: Int -> (x -> Promise Boolean) -> [x] -> Promise x\r\n\r\n\r\n\r\n### parallel-sequence\r\nSynonym for `sequenceP`\r\n\r\n\tparallel-sequence :: [Promise x] -> Promise [x]\r\n\r\n\r\n\r\n### serial-sequence\r\nThe serial version of `sequenceP`.\r\n\r\nTo run the list one by one in a serial order, its items\r\nmust be instances of `LazyPromise` type.\r\nThis function runs the list in parallel, if it is a list \r\nof normal `Promise` s.\r\n\r\n\tserial-sequence :: [LazyPromise x] -> LazyPromise [x]\r\n\r\n\r\n\r\n### parallel-limited-sequence\r\n\r\n\tparallel-limited-sequence :: Int -> [LazyPromise x] -> LazyPromise [x]\r\n\r\n\r\n\r\n### parallel-apply-each\r\n\r\n\tparallel-apply-each :: x -> [x -> Promise y] -> Promise [y]\r\n\r\n\r\n\r\n### serial-apply-each\r\n\r\n\tserial-apply-each :: x -> [x -> Promise y] -> Promise [y]\r\n\r\n\r\n\r\n### parallel-limited-apply-each\r\n\r\n\tparallel-limited-apply-each :: x -> [x -> Promise y] -> Promise [y]\r\n\r\n\r\n\r\n### parallel-sort-by\r\nSort the list using the given function for making the comparison between the items.\r\n\r\n\tparallel-sort-by :: (a -> Promise b) -> [a] -> Promise [a]\r\n\r\n\r\n\r\n### parallel-sort-with\r\n`parallel-sort-with` takes a binary function which compares two items and returns either\r\na positive number, 0, or a negative number, and sorts the inputted list\r\nusing that function. \r\n\r\n\tparallel-sort-with :: (a -> a -> Promise i) -> [a] -> Promise [a]\r\n\r\n\r\n\r\n### waterfall\r\n\r\n\twaterfall :: x -> (x -> Promise x) -> Promise x\r\n\r\n\r\n\r\n### transform-promise-either\r\nBind a promise monad to an either monad. The result is a promise monad. \r\nSince we can think of promise as a superset of either in the way it handles errors.\r\n\r\n\ttransform-promise-either :: Promise x -> (x -> Either y) -> Promise y\r\n\r\n\r\n\r\n### ftransform-promise-either\r\n`transform-promise-either` with its arguments flipped.\r\n\r\n\tftransform-promise-either :: (x -> Either y) -> Promise x -> Promise y\r\n\r\n\r\n\r\n### transform-either-promise\r\nBind an either monad to a promise monad.\r\n\r\n\ttransform-either-promise :: Either x -> (x -> Promise y) -> Promise y\r\n\r\n\r\n\r\n### ftransform-either-promise\r\n`transform-either-promise` with its arguments flipped.\r\n\r\n\tftransform-either-promise :: (x -> Promise y) -> Either x -> Promise y\r\n\r\n\r\n\r\n### to-callback\r\nConvert the promise object to a callback with the signature of `(error, result) -> void`\r\n\r\n\tPromise x -> CB x\r\n\r\n\r\n\r\n### from-value-callback\r\nMake a promise object from a callback with the signature of `(result) -> void`, like `fs.exist`\r\n\r\n\tCb x -> Promise x\r\n\r\n\r\n\r\n### from-error-value-callback\r\nMake a promise object from a callback with the signature of `(error, result) -> void`, like `fs.stat`\r\n\r\n\tCB x -> Promise x\r\n\r\n\r\n\r\n### from-named-callbacks\r\nMake a promise object from `obj`.\r\n\r\n\tString -> String -> obj -> Promise x\r\n\r\n---\r\n\r\n---\r\n\r\n---\r\n\r\n# Callbacks\r\nThese functions are analogous to their promise-based counterparts that are documented above.\r\nBut instead of a `Promise` their last argument is a callback. You can think of curried version of these functions as functions that return a function that takes `callback`.\r\n\r\n    {callbacks} = require \\prelude-ls\r\n\r\n## Convention\r\n\r\nThis would be our definition of asynchronous functions:\r\n> If function `f` returns function `g` and `g` takes a `callback` as its only argument; then `f` is an asynchronous function.\r\n\r\nOur callbacks will always receive two parameters: `(error, result)`.\r\n\r\nHere `CB a` stands for a callback function with signature: `(err, a) -> void`\r\nYou can get the result of an asynchronous function (with a `callback` of type of `CB a`) by:\r\n\r\n\t(err, a) <- f\r\n\r\n## Composition of Asynchronous Actions\r\n\r\n### returnA\r\nInject a value into an asynchronous action.\r\n\r\n\treturnA :: x -> CB x\r\n\r\n\r\n### fmapA\r\nMap a normal function over an asynchronous action.\r\n\r\n\tfmapA :: (x -> y) -> CB x -> CB y\r\n\r\n\r\n### ffmapA\r\nfmapA with its arguments flipped\r\n\r\n\tffmapA :: CB x -> (x -> y) -> CB y\r\n\r\n\r\n### bindA\r\nSequentially compose two asynchronous actions, passing the value produced\r\nby the first as an argument to the second.\r\n\r\n\tbindA :: CB x -> (x -> CB y) -> CB y\r\n\r\n\r\n### fbindA\r\nbindA with its arguments flipped\r\n\r\n\tfbindA :: (x -> CB y) -> CB x -> CB y\r\n\r\n### kcompA\r\nSimilar to Left-to-right Kleisli composition, `kcompA` composes\r\ntwo asynchronous actions passing the value produced\r\nby the first as an argument to the second. The result is a new\r\nasynchronous function that takes the argument of the first function.\r\n\r\n\tkcompA :: (x -> CB y) -> (y -> CB z) -> (x -> CB z)\r\n\r\n\r\n### foldA\r\nThe `foldA` function is analogous to `foldl`, except that its result is\r\nencapsulated in an asynchronous callback.\r\n\r\n\tfoldA :: (a -> b -> m a) -> a -> [b] -> m a\r\n\r\n\r\n### sequenceA\r\nEvaluate each action in the sequence from left to right,  and collect the results.\r\n\r\n\tsequenceA :: [CB x] -> CB [x]\r\n\r\n\r\n### filterA\r\nFilter the list by applying the asynchronous predicate function.\r\n\r\n\tfilterA :: (x -> CB Boolean) -> [x] -> CB [x]\r\n\r\n\r\n\r\n## Either\r\n\r\n### returnE\r\nInject a value into an either action.\r\n\r\n\treturnE :: x -> Either x\r\n\r\n### fmapE\r\n    fmapE :: (x -> y) -> Either x -> Either y\r\n\r\n\r\n### fmapE\r\n    ffmapE :: Either x -> (x -> y) -> Either y\r\n\r\n\r\n### bindE\r\n\r\n    bindE :: Either x -> (x -> Either y) -> Either y\r\n\r\n### bindE\r\n\r\n    bindE :: (x -> Either y) -> Either x -> Either y\r\n\r\n\r\n### kcompE\r\n\r\nLeft to right Kleisli composition\r\n    \r\n    kcompE :: (x -> Either y) -> (y -> Either z) -> (x -> Either z)\r\n\r\n\r\n### foldE\r\n\r\n    foldE :: (a -> b -> Either a) -> a -> [b] -> Either a\r\n\r\n\r\n### sequenceE\r\n\r\n    sequenceE :: [Either x] -> Either [x]\r\n\r\n\r\n### transformAE\r\n\r\n    transformAE :: CB x -> (x -> Either y) -> CB y\r\n\r\n\r\n### ftransformAE\r\n\r\n    ftransformAE :: (x -> Either y) -> CB x -> CB y\r\n\r\n### transformEA\r\n\r\n    transformEA :: Either x -> (x -> CB y) -> CB y\r\n\r\n### ftransformEA\r\n\r\n    ftransformEA :: (x -> CB y) -> Either x -> CB y\r\n\r\n\r\n# Lists\r\n\r\n## Map\r\n\r\n### parallel-map\r\n\r\n\tparallel-map :: (a -> CB b) -> [a] -> CB [b]\r\n\r\n\r\n### serial-map\r\nSerial Asynchronous Map\r\n\r\n\tserial-map :: (a -> CB b) -> [a] -> CB [b]\r\n\r\n\r\n### parallel-map-limited\r\nSimilar to `parallel-map`, only no more than \r\n`limit` iterators will be simultaneously running at any time.\r\n\r\n\tparallel-map-limited :: Int -> (x -> CB y) -> [x] -> CB [y]\r\n\r\n\r\n## Filter\r\n\r\n### parallel-filter\r\n\r\n\tparallel-filter :: (x -> CB Boolean) -> [x] -> CB [x]\r\n\r\n\r\n### serial-filter\r\n\r\n\tserial-filter :: (x -> CB Boolean) -> [x] -> CB [x]\r\n\r\n\r\n### parallel-limited-filter\r\n\r\n\tparallel-limited-filter :: Int -> (x -> CB Boolean) -> [x] -> CB x\r\n\r\n\r\n## Any, All, Find\r\n\r\n\r\n### parallel-any\r\n\r\n\tparallel-any :: (x -> CB Boolean) -> [x] -> CB Boolean\r\n\r\n\r\n### serial-any\r\n\r\nserial-any :: (x -> CB Boolean) -> [x] -> CB Boolean\r\n\r\n\r\n### parallel-limited-any\r\n\r\n\tparallel-limited-any :: Int -> (x -> CB Boolean) -> [x] -> CB Boolean\r\n\r\n\r\n### parallel-all\r\n\r\n\tparallel-all :: (x -> CB Boolean) -> [x] -> CB Boolean\r\n\r\n\r\n### serial-all\r\n\r\n\tserial-all :: (x -> CB Boolean) -> [x] -> CB Boolean\r\n\r\n\r\n### parallel-limited-all\r\n\r\n\tparallel-limited-all :: Int -> (x -> CB Boolean) -> [x] -> CB Boolean\r\n\r\n\r\n### parallel-find\r\n\r\n\tparalel-find :: (x -> CB Boolean) -> [x] -> CB x\r\n\r\n\r\n### serial-find\r\n\r\n\tserial-find :: (x -> CB Boolean) -> [x] -> CB x\r\n\r\n\r\n## Sort\r\n\r\n### parallel-sort-by\r\nSorts a list using the inputted function for making the comparison between the items.\r\n\r\n\tparallel-sort-by :: (a -> CB b) -> [a] -> CB [a]\r\n\r\n\r\n### parallel-sort-with\r\nTakes a binary function which compares two items and returns either\r\na positive number, 0, or a negative number, and sorts the inputted list\r\nusing that function. \r\n\r\n\tparallel-sort-with :: (a -> a -> CB i) -> [a] -> CB [a]\r\n\r\n\r\n## Control Flow\r\n\r\n### serial-sequence\r\n\tserial-sequence :: [CB x] -> CB [x]\r\n\r\n\r\n### parallel-sequence\r\nRun its sole input (a tasks array of functions) in parallel, \r\nwithout waiting until the previous function has completed. \r\nIf any of the functions pass an error to its callback, \r\nthe main callback is immediately called with the value of the error. \r\nOnce the tasks have completed, the results are passed to the final callback as an array.\r\n\r\n\tparallel-sequence :: [CB x] -> CB [x]\r\n\r\n\r\n### parallel-limited-sequence\r\n\r\n\tparallel-limited-sequence :: Int -> [CB x] -> CB [x]\r\n\r\n\r\n### parallel-apply-each\r\n\r\n\tparallel-apply-each :: x -> [x -> CB y] -> CB [y]\r\n\r\n\r\n### serial-apply-each\r\n\r\n\tserial-apply-each :: x -> [x -> CB y] -> CB [y]\r\n\r\n\r\n### parallel-limited-apply-each\r\n\r\n\tparallel-limited-apply-each :: x -> [x -> CB y] -> CB [y]\r\n\r\n\r\n### waterfall\r\n\r\n\twaterfall :: x -> (x -> CB x) -> CB x\r\n\r\n\r\n### serial-fold\r\n\r\n\tserial-fold :: (a -> b -> m a) -> a -> [b] -> m a\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}