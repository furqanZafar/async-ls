// Generated by LiveScript 1.2.0
(function(){
  var odd, ref$, returnL, bindL, ffmapA, returnA, bindA, parallelMapLimited, serialMap, parallelMap, parallelFilter, serialFilter, parallelLimitedFilter, parallelAny, parallelLimitedAny, parallelAll, serialAll, parallelLimitedAll, assert, _it, nTimes, doubleA, lessThan6A, arr;
  odd = require('prelude-ls').odd;
  ref$ = require('./../build/compositions'), returnL = ref$.returnL, bindL = ref$.bindL, ffmapA = ref$.ffmapA, returnA = ref$.returnA, bindA = ref$.bindA;
  ref$ = require('./../build/lists'), parallelMapLimited = ref$.parallelMapLimited, serialMap = ref$.serialMap, parallelMap = ref$.parallelMap, parallelFilter = ref$.parallelFilter, serialFilter = ref$.serialFilter, parallelLimitedFilter = ref$.parallelLimitedFilter, parallelAny = ref$.parallelAny, parallelLimitedAny = ref$.parallelLimitedAny, parallelAll = ref$.parallelAll, serialAll = ref$.serialAll, parallelLimitedAll = ref$.parallelLimitedAll;
  assert = require('assert');
  _it = it;
  nTimes = curry$(function(n, p){
    var i$, i, results$ = [];
    for (i$ = 0; i$ <= n; ++i$) {
      i = i$;
      results$.push(p * i);
    }
    return results$;
  });
  doubleA = curry$(function(x, callback){
    return setTimeout(function(){
      return callback(null, 2 * x);
    }, 10);
  });
  lessThan6A = curry$(function(x, callback){
    return setTimeout(function(){
      return callback(null, x < 6);
    }, 10);
  });
  describe('Compositions', function(){
    describe('bindL', function(){
      _it('on [] should be []', function(){
        return assert.deepEqual([], bindL([], nTimes(3)));
      });
      return _it('should be [ 0, 4, 8, 12, 0, 6, 12, 18 ]', function(){
        return assert.deepEqual([0, 4, 8, 12, 0, 6, 12, 18], bindL([4, 6], nTimes(3)));
      });
    });
    describe('parallel-map', function(){
      _it('on [] should be []', function(done){
        return parallelMap(doubleA, [], function(err, res){
          assert.deepEqual([], res);
          return done();
        });
      });
      return _it('on [1,2,3] should be [2,4,6]', function(done){
        return parallelMap(doubleA, [1, 2, 3], function(err, res){
          assert.deepEqual([2, 4, 6], res);
          return done();
        });
      });
    });
    describe('serial-map', function(){
      _it('on [] should be []', function(done){
        return serialMap(doubleA, [], function(err, res){
          assert.deepEqual([], res);
          return done();
        });
      });
      return _it('on [1,2,3] should be [2,4,6]', function(done){
        return serialMap(doubleA, [1, 2, 3], function(err, res){
          assert.deepEqual([2, 4, 6], res);
          return done();
        });
      });
    });
    describe('parallel-filter', function(){
      _it('on [] should be []', function(done){
        return parallelFilter(lessThan6A, [], function(err, res){
          assert.deepEqual([], res);
          return done();
        });
      });
      return _it('on [1,2,3,4,5,6,7,8,9,10] should be [1,2,3,4,5]', function(done){
        return parallelFilter(lessThan6A, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
          assert.deepEqual([1, 2, 3, 4, 5], res);
          return done();
        });
      });
    });
    return describe('parallel-limited-any', function(){
      return _it('on [1 to 100] should be true', function(done){
        var count, moreThan3A;
        count = 0;
        moreThan3A = curry$(function(x, callback){
          count = count + 1;
          return setTimeout(function(){
            return callback(null, x > 3);
          }, 10);
        });
        return parallelLimitedAny(3, moreThan3A, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100], function(err, res){
          assert.deepEqual(true, res);
          assert.equal(6, count);
          return done();
        });
      });
    });
  });
  return;
  arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
  parallelMapLimited(3, function(x, callback){
    return callback(null, x + "!");
  }, arr, function(err, res){
    var f1, f2, f3, f4, f5;
    console.log(err, res);
    f1 = function(x, callback){
      return setTimeout(function(){
        return callback(null, x * x);
      }, 200);
    };
    f2 = function(x, callback){
      return setTimeout(function(){
        return callback(x === 7 ? 'ERROR at 7' : null, odd(x * x));
      }, 100);
    };
    f3 = curry$(function(x, callback){
      return setTimeout(function(){
        return callback(null, odd(x * x));
      }, 100);
    });
    f4 = function(x, callback){
      return setTimeout(function(){
        return callback(null, x * x > -1);
      }, 100);
    };
    f5 = curry$(function(x, callback){
      return setTimeout(function(){
        return callback(null, x <= 5);
      }, 100);
    });
    return parallelFilter(f3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
      console.log('parallel-filter', err, res);
      return serialFilter(f3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
        console.log('serial-filter', err, res);
        return parallelLimitedFilter(3, f3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
          console.log('parallel-limited-filter', err, res);
          return parallelAny(f3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
            console.log(err, res);
            return parallelLimitedAny(3, f3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
              console.log('parallel-limited-any', err, res);
              return parallelAll(f3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
                console.log('parallel-all', err, res);
                return serialAll(f3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(err, res){
                  console.log('serial-all', err, res);
                  return parallelLimitedAll(3, f5, [0, 1, 2, 3, 4, 5], function(err, res){
                    return console.log('parallel-limited-all', err, res);
                  });
                });
              });
            });
          });
        });
      });
    });
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
